### 7장 연산자

---

### 7.1 산술 연산자

산술 연산자는 연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듭니다. 산술 연산이 불가능할 경우 NaN을 반환합니다.

### 7.1.2 단항 산술 연산자

단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만듭니다.

```jsx
var x = 7;

// ++ 연산자는 피 연산자의 값을 변경하는 암묵적 할당이 이루어집니다.
x++; // x = x + 1;
console.log(x); // 8

// -- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이루어집니다.
x--;
console.log(x); // 7
```

++ / - - 연산자는 전위이냐, 후위이냐 위치에 따라 의미가 크게 달라집니다.

```jsx
var x = 5;
result;

// 선할당 후 증가
result = x++;
console.log(result, x); // 5, 6

// 선증가 후 할당
result = ++x; // x = 6
console.log(result, x); // 7, 7
```

숫자 타입이 아닌, 피 연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환합니다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환해줍니다.

```jsx
var x = '1';

console.log(+x); // 1

// bool 값도, 숫자 타입으로 변환합니다 true: 1 false: 0
x = true;
console.log(+x); // 1

y = false;
console.log(+y); // 0
console.log(y); // false 부수적 효과는 없다.

// 문자열은 숫자 타입으로 변환 X NaN return
x = 'hi';
console.log(+x); // NaN
console.log(x); // 'hi'
```

### 7.1.3 문자열 연결 연산자

- 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작합니다.

```jsx
// 문자열 연결 연산자
'1' + 2; // -> '12'

// true는 1로 타입 변환
1 + true; // -> 2

// false는 0으로 타입 변환
1 + false; // -> 1

// null은 0으로 타입변환
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined; // -> NaN
1 + undefined; // NaN
```

---

### 7-2 할당 연산자

이 부분은, 너무 많이 사용하는 부분이기에 자세한 설명은 생략하겠다. 할당 연산자란 `=, +=, -=, *=, /=, %=`과 같은 연산자라고 생각하면된다.

할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.

---

### 7-3 비교 연산자

`동등 비교(==) 연산자`는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 확인한다.

```jsx
5 == 5; // true
5 == '5'; // type은 다르지만 암묵적으로 타입을 일치시킴
```

이러한 점 떄문에, 결과를 예측하기 어렵고 실수하기도 쉽다.

`일치 비교(===)연산자`는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 다시 말해, 암묵적 타입 변환을 하지 않고 값을 비교한다.

```jsx
// 일치 비교
5 === 5; // true

5 === '5'; // 타입이 다르기에 false
```

일치 비교 연산자에서 주의할 것은 NaN이다. 추가적으로 양의 0과 음의 0도 주의해주면 좋다.

```jsx
// NaN은 자기 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // false

// 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true

// 양의 0과, 음의 0도 추가적으로 주의해주자.
0 === -0; // true
(0 ==
  -0 - // true
    // +0과 -0을 동일하게보고, NaN과 NaN을 다르게 보는 문제점을 해결하기위해
    // ES6에서 Object.is 연산자가 등장했다.
    0) ===
  +0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

### 7.3.2 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 `bool 값`을 반환한다.

---

### 7.4 삼항 조건 연산자 (Ternary Operator)

`조건식 ? 조건식이 true일때 반환 값 : 조건식이 false일떄 반환 값`

위의 공식 처럼 사용하면된다.

```jsx
let x = 20;

let result = x % 2 ? '홀수' : '짝수';
console.log(result); // 짝수
```

---

### 7.5 논리 연산자

| 논리 연산자 | 의미        | 부수 효과 |                            |
| ----------- | ----------- | --------- | -------------------------- | --- | ------------------------------- |
|             |             |           | 논리합(OR)                 | X   | 둘중 하나만 참/거짓 ⇒ 참 / 거짓 |
| &&          | 논리곱(AND) | X         | 둘다 참 / 거짓 ⇒ 참 / 거짓 |
| !           | 부정(NOT)   | X         | 참 ⇒ 거짓 , 거짓 → 참      |

논리 부정 연산자 !는, 언제나 불리언 값을 반환한다.

```jsx
!0; // true
!'Hello'; // false
```

논리 합, 논리 곱 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 있다. 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

```jsx
// 단축평가
'CAT' && 'DOG'; // 'DOG'
```

---

### 7.6 쉼표 연산자

쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환합니다.

```jsx
let x, y, z;

(x = 3), (y = 4), (z = 5); // 5
```

---

### 7.7 그룹 연산자

그룹 연산자는 소괄호로, 피연산자를 감싸는 표현식을 가장 먼저 평가합니다.

```jsx
10 * 2 + 3; // -> 23
10 * (2 + 3); // -> 50
```

---

### 7.8 typeof 연산자

typeof연산자는 피연산자의 데이터 타입을 문자열로 반환합니다.

```jsx
typeof ''; // -> string
typeof NaN; // -> number
typeof Symbol(); // -> symbol
```

typeof 연산자로 null 값을 연산해보면 “null”이 아닌 “object”를 반환한다는데 주의하자. 이것은 자바스크립트의 첫 번쨰 버전의 버그다. 기존 코드에 영향을 줄 수 있기에 수정하지 않고 있다.

값이 null 타입인지 확인할 떄는 typeof 연산자보돠, 일치 연산자를 사용하자(===)

```jsx
var foo = null;

typeof foo === null; // false
foo === null; // true

// 선언하지 않은 식별자를 typeof 연산자로 연산시 ReferenceError가 아닌, undefined
// 를반환한다.
typeof undeclared; // undefined
```

---

### 7.9 지수 연산자

```jsx
2 ** 2; // 4
2 ** 2.5; // 5.656854....
```

ES7에서 도입되었고 좌항을 밑으로, 우항을 지수로 거듭제곱하여 숫자를 반환한다.

지수 연산자가 도입되기 이전에는 `Math.pow` 메서드를 사용했다.

```jsx
Math.pow(2, 2); // -> 4
Math.pow(2, 2.5); // 5.65....
```

음수를 거듭제곱의 밑으로 사용해 계산하려면 다음과 같이 괄호로 묶어야 한다.

```jsx
-5 ** 2;
// Syntax Error

(-5) ** 2; // -> 25
```

---

### 7.10 그 외의 연산자

?. , ??, delete, new 등 다양한 연산자가 있는데 나중에 차근차근 챕터를 공부하면서 자세하게 공부해보자!

---

### 7.11 연산자의 부수효과

대부분의 연산자는 다른 코드에 영향을 미치지 않는다. 하지만, 할당 연산자(=), 증가/감소 연산자(++, —), delete 연산자는 영향을 준다.

```jsx
var x;

// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.
// 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
x = 1;
console.log(x); // 1

// 즈악 감소 연산자도 동일하다. 재할당되어 변경되기 떄문이다.
x++;
console.log(x); // 2

var o = { a: 1 };

// delete 연산자는 객체의 프로퍼티를 삭제하는 효과가 있따.
delete o.a;
console.log(o); // {}
```

---
